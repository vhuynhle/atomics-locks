#include <atomic>
#include <chrono>
#include <cstddef>
#include <cstdint>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <stdexcept>
#include <syncstream>
#include <thread>
#include <vector>

std::uint64_t generate_random_key()
{
#ifdef _WIN32
    std::abort("Not implemented for Windows");
#endif

    static constexpr auto kMinDuration = std::chrono::milliseconds { 100 };
    const auto startTime = std::chrono::steady_clock::now();

    std::ifstream ifs { "/dev/random" };
    if (ifs.fail()) {
        throw std::runtime_error { "Cannot open random device" };
    }

    std::uint64_t result { 0 };
    while (result == 0) {
        ifs.read(reinterpret_cast<char*>(&result), sizeof(result));
        if (static_cast<std::size_t>(ifs.gcount()) < sizeof(result)) {
            throw std::runtime_error { "Failed to read random data" };
        }
    }

    const auto currentTime = std::chrono::steady_clock::now();
    const auto elapsed = currentTime - startTime;
    if (elapsed < kMinDuration) {
        std::this_thread::sleep_for(kMinDuration - elapsed);
    }

    return result;
}

std::uint64_t get_key()
{
    static auto atomic_key = std::atomic_uint64_t { 0 };
    auto key = atomic_key.load(std::memory_order_relaxed);
    auto synced_cout = std::osyncstream { std::cout };
    const auto tid = std::this_thread::get_id();
    if (key == 0) {
        synced_cout << "[" << tid << "] generating key ...\n";
        const auto new_key = generate_random_key();
        if (atomic_key.compare_exchange_strong(key, new_key, std::memory_order_relaxed)) {
            synced_cout << " ====== Key generated by thread " << tid
                        << ":" << new_key << "  =====\n";
            return new_key;
        } else {
            synced_cout << "[" << tid << "] is too late, work wasted << "
                        << key << "\n";
            return key;
        }
    } else {
        synced_cout << "[" << tid << "]: Nothing to do " << key << "\n";
        return key;
    }
}

int main()
{
    std::vector<std::jthread> threads;
    for (auto i { 0 }; i < 20; ++i) {
        threads.emplace_back(get_key);
        std::this_thread::sleep_for(std::chrono::milliseconds { 20 });
    }

    return 0;
}
